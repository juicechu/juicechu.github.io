<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Archives | juice 博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="blog.zhuxi.me">
<meta property="og:type" content="website">
<meta property="og:title" content="juice 博客">
<meta property="og:url" content="http://blog.zhuxi.me/archives/page/2/index.html">
<meta property="og:site_name" content="juice 博客">
<meta property="og:description" content="blog.zhuxi.me">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="juice 博客">
<meta name="twitter:description" content="blog.zhuxi.me">
  
    <link rel="alternative" href="/atom.xml" title="juice 博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="http://tp2.sinaimg.cn/1753087561/180/40032232067/1" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">juice</a></h1>
		</hgroup>

		
		<p class="header-subtitle">新的开始</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/categories/原创">原创</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/juicechu" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/zhuxige/profile?rightmod=1&wvr=6&mod=personinfo" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/zhu-jia-jun-2" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.linode.com/">linode</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">计算机中的艺术家</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">juice</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://tp2.sinaimg.cn/1753087561/180/40032232067/1" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">juice</h1>
			</hgroup>
			
			<p class="header-subtitle">新的开始</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/categories/原创">原创</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/juicechu" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/zhuxige/profile?rightmod=1&wvr=6&mod=personinfo" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/zhu-jia-jun-2" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-2014-05-fastcgi-finish-request" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/05/20/2014-05-fastcgi-finish-request/" class="article-date">
  	<time datetime="2014-05-20T10:05:00.000Z" itemprop="datePublished">2014-05-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/20/2014-05-fastcgi-finish-request/">使用fastcgi_finish_request提高页面响应速度</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>PHP运行在FastCGI模式时,PHP FPM提供了一个名为fastcgi_finish_request的方法.按照文档上的说法,此方法可以提高请求的处理速度,如果有些处理可以在页面生成完后再进行,就可以使用这个方法.</p>
<p>听起来可能有些茫然,我们通过几个例子来说明一下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'例子：'</span>;</span><br><span class="line">fastcgi_finish_request(); <span class="comment">/* 响应完成, 关闭连接 */</span></span><br><span class="line"><span class="comment">/* 记录日志 */</span></span><br><span class="line">file_put_contents(<span class="string">'log.txt'</span>, <span class="string">'生存还是毁灭,这是个问题.'</span>);</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过浏览器访问此脚本, 结果发现并没有输出相应的字符串,但却生成了相应的文件.由此说明在调用fastcgi_finish_request后,客户端响应就已经结束,但与此同时服务端脚本却继续运行！</p>
<p>合理利用这个特性可以大大提升用户体验,趁热打铁再来一个例子：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'例子：'</span>;</span><br><span class="line">file_put_contents(<span class="string">'log.txt'</span>, date(<span class="string">'Y-m-d H:i:s'</span>) . <span class="string">" 上传视频\n"</span>, FILE_APPEND);</span><br><span class="line">fastcgi_finish_request();</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">file_put_contents(<span class="string">'log.txt'</span>, date(<span class="string">'Y-m-d H:i:s'</span>) . <span class="string">" 转换格式\n"</span>, FILE_APPEND);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">file_put_contents(<span class="string">'log.txt'</span>, date(<span class="string">'Y-m-d H:i:s'</span>) . <span class="string">" 提取图片\n"</span>, FILE_APPEND);</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>代码里用sleep模拟一些耗时的操作,浏览时没有被堵塞,程序却都执行了,具体看日志.</p>
<p>末了给您提个醒,Yahoo在Best Practices for Speeding Up Your Web Site中提到了Flush the Buffer Early,也就是利用PHP中的flush方法把内容尽快发到客户端去,它和本文介绍的fastcgi_finish_request有些许的类似.</p>
<p>转载附言: 我看了下这个方法, 在调用的时候, 会发送响应, 关闭连接. 但是不会结束PHP的运行. 相比调用flush, 或者我之前介绍的加速你的Echo来说, 这个方法能更加干脆一些.</p>
<p>另外, 从代码的可移植性讲的话, 可以在代码中附上如下代码:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!function_exists(<span class="string">"fastcgi_finish_request"</span>)) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fastcgi_finish_request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不会造成代码部署在非fpm环境下造成问题.</p>
<p>文章转自: <a href="http://huoding.com/2011/04/12/63" target="_blank" rel="external">火丁笔记</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/转载/">转载</a><a class="article-category-link" href="/categories/转载/PHP/">PHP</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-2014-05-php5.2-upgrade-php5.6" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/05/20/2014-05-php5.2-upgrade-php5.6/" class="article-date">
  	<time datetime="2014-05-20T01:17:00.000Z" itemprop="datePublished">2014-05-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/20/2014-05-php5.2-upgrade-php5.6/">PHP 自 5.2 到 5.6 中新增的功能详解</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="截至目前(2014-2),_PHP_的最新稳定版本是_PHP5-5,_但有差不多一半的用户仍在使用已经不在维护_[注]_的_PHP5-2,_其余的一半用户在使用_PHP5-3_[注]-">截至目前(2014.2), PHP 的最新稳定版本是 PHP5.5, 但有差不多一半的用户仍在使用已经不在维护 [注] 的 PHP5.2, 其余的一半用户在使用 PHP5.3 [注].</h2><p>因为 PHP 那“集百家之长”的蛋疼语法，加上社区氛围不好，很多人对新版本，新特征并无兴趣。<br>本文将会介绍自 PHP5.2 起，直至 PHP5.6 中增加的新特征。</p>
<p>PHP5.2 以前：autoload, PDO 和 MySQLi, 类型约束<br>PHP5.2：JSON 支持<br>PHP5.3：弃用的功能，匿名函数，新增魔术方法，命名空间，后期静态绑定，Heredoc 和 Nowdoc, const, 三元运算符，Phar<br>PHP5.4：Short Open Tag, 数组简写形式，Traits, 内置 Web 服务器，细节修改<br>PHP5.5：yield, list() 用于 foreach, 细节修改<br>PHP5.6: 常量增强，可变函数参数，命名空间增强<br>注：已于2011年1月停止支持： <a href="http://www.php.net/eol.php" target="_blank" rel="external">http://www.php.net/eol.php</a><br>注：<a href="http://w3techs.com/technologies/details/pl-php/5/all" target="_blank" rel="external">http://w3techs.com/technologies/details/pl-php/5/all</a></p>
<p>PHP5.2以前</p>
<p>(2006前)<br>顺便介绍一下 PHP5.2 已经出现但值得介绍的特征。</p>
<p>autoload</p>
<p>大家可能都知道 __autoload() 函数，如果定义了该函数，那么当在代码中使用一个未定义的类的时候，该函数就会被调用，你可以在该函数中加载相应的类实现文件，如：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__autoload</span><span class="params">(<span class="variable">$classname</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">require_once</span>(<span class="string">"&#123;$classname&#125;.php"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但该函数已经不被建议使用，原因是一个项目中仅能有一个这样的 __autoload() 函数，因为 PHP 不允许函数重名。但当你使用一些类库的时候，难免会出现多个 autoload 函数的需要，于是 spl_autoload_register() 取而代之：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spl_autoload_register(<span class="function"><span class="keyword">function</span><span class="params">(<span class="variable">$classname</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">require_once</span>(<span class="string">"&#123;$classname&#125;.php"</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>spl_autoload_register() 会将一个函数注册到 autoload 函数列表中，当出现未定义的类的时候，SPL [注] 会按照注册的倒序逐个调用被注册的 autoload 函数，这意味着你可以使用 spl_autoload_register() 注册多个 autoload 函数.</p>
<p>注：SPL: Standard PHP Library, 标准 PHP 库, 被设计用来解决一些经典问题(如数据结构).</p>
<p>PDO 和 MySQLi</p>
<p>即 PHP Data Object, PHP 数据对象，这是 PHP 的新式数据库访问接口。</p>
<p>按照传统的风格，访问 MySQL 数据库应该是这样子：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 连接到服务器，选择数据库</span></span><br><span class="line"><span class="variable">$conn</span> = mysql_connect(<span class="string">"localhost"</span>, <span class="string">"user"</span>, <span class="string">"password"</span>);</span><br><span class="line">mysql_select_db(<span class="string">"database"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 执行 SQL 查询</span></span><br><span class="line"><span class="variable">$type</span> = <span class="variable">$_POST</span>[<span class="string">'type'</span>];</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">"SELECT * FROM `table` WHERE `type` = &#123;$type&#125;"</span>;</span><br><span class="line"><span class="variable">$result</span> = mysql_query(<span class="variable">$sql</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="keyword">while</span>(<span class="variable">$row</span> = mysql_fetch_array(<span class="variable">$result</span>, MYSQL_ASSOC))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$row</span> <span class="keyword">as</span> <span class="variable">$k</span> =&gt; <span class="variable">$v</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"&#123;$k&#125;: &#123;$v&#125;\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 释放结果集，关闭连接</span></span><br><span class="line">mysql_free_result(<span class="variable">$result</span>);</span><br><span class="line">mysql_close(<span class="variable">$conn</span>);</span><br></pre></td></tr></table></figure>
<p>为了能够让代码实现数据库无关，即一段代码同时适用于多种数据库(例如以上代码仅仅适用于MySQL)，PHP 官方设计了 PDO.</p>
<p>除此之外，PDO 还提供了更多功能，比如：</p>
<ol>
<li>面向对象风格的接口</li>
<li>SQL预编译(prepare), 占位符语法</li>
<li>更高的执行效率，作为官方推荐，有特别的性能优化</li>
<li>支持大部分SQL数据库，更换数据库无需改动代码</li>
</ol>
<p>上面的代码用 PDO 实现将会是这样：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接到数据库</span></span><br><span class="line"><span class="variable">$conn</span> = <span class="keyword">new</span> PDO(<span class="string">"mysql:host=localhost;dbname=database"</span>, <span class="string">"user"</span>, <span class="string">"password"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预编译SQL, 绑定参数</span></span><br><span class="line"><span class="variable">$query</span> = <span class="variable">$conn</span>-&gt;prepare(<span class="string">"SELECT * FROM `table` WHERE `type` = :type"</span>);</span><br><span class="line"><span class="variable">$query</span>-&gt;bindParam(<span class="string">"type"</span>, <span class="variable">$_POST</span>[<span class="string">'type'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行查询并打印结果</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$query</span>-&gt;execute() <span class="keyword">as</span> <span class="variable">$row</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="variable">$row</span> <span class="keyword">as</span> <span class="variable">$k</span> =&gt; <span class="variable">$v</span>)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"&#123;$k&#125;: &#123;$v&#125;\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PDO 是官方推荐的，更为通用的数据库访问方式，如果你没有特殊需求，那么你最好学习和使用 PDO.<br>但如果你需要使用 MySQL 所特有的高级功能，那么你可能需要尝试一下 MySQLi, 因为 PDO 为了能够同时在多种数据库上使用，不会包含那些 MySQL 独有的功能。</p>
<p>MySQLi 是 MySQL 的增强接口，同时提供面向过程和面向对象接口，也是目前推荐的 MySQL 驱动，旧的C风格 MySQL 接口将会在今后被默认关闭。<br>MySQLi 的用法和以上两段代码相比，没有太多新概念，在此不再给出示例，可以参见 PHP 官网文档 [注]。</p>
<p>注：<a href="http://www.php.net/manual/en/mysqli.quickstart.php" target="_blank" rel="external">http://www.php.net/manual/en/mysqli.quickstart.php</a></p>
<p>类型约束</p>
<p>通过类型约束可以限制参数的类型，不过这一机制并不完善，目前仅适用于类和 callable(可执行类型) 以及 array(数组), 不适用于 string 和 int.</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限制第一个参数为 MyClass, 第二个参数为可执行类型，第三个参数为数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyFunction</span><span class="params">(MyClass <span class="variable">$a</span>, callable <span class="variable">$b</span>, array <span class="variable">$c</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PHP5.2</p>
<p>(2006-2011)</p>
<p>JSON 支持</p>
<p>包括 json_encode(), json_decode() 等函数，JSON 算是在 Web 领域非常常用的数据交换格式，可以被 JS 直接支持，JSON 实际上是 JS 语法的一部分。<br>JSON 系列函数，可以将 PHP 中的数组结构与 JSON 字符串进行转换：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$array</span> = [<span class="string">"key"</span> =&gt; <span class="string">"value"</span>, <span class="string">"array"</span> =&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line"><span class="variable">$json</span> = json_encode(<span class="variable">$array</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&#123;$json&#125;\n"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="variable">$object</span> = json_decode(<span class="variable">$json</span>);</span><br><span class="line">print_r(<span class="variable">$object</span>);</span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">"key"</span>:<span class="string">"value"</span>,<span class="string">"array"</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]&#125;</span><br><span class="line">stdClass Object</span><br><span class="line">(</span><br><span class="line"> [key] =&gt; value</span><br><span class="line"> [<span class="keyword">array</span>] =&gt; <span class="keyword">Array</span></span><br><span class="line">    (</span><br><span class="line">        [<span class="number">0</span>] =&gt; <span class="number">1</span></span><br><span class="line">        [<span class="number">1</span>] =&gt; <span class="number">2</span></span><br><span class="line">        [<span class="number">2</span>] =&gt; <span class="number">3</span></span><br><span class="line">        [<span class="number">3</span>] =&gt; <span class="number">4</span></span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>值得注意的是 json_decode() 默认会返回一个对象而非数组，如果需要返回数组需要将第二个参数设置为 true.</p>
<p>PHP5.3</p>
<p>(2009-2012)</p>
<p>PHP5.3 算是一个非常大的更新，新增了大量新特征，同时也做了一些不向下兼容的修改。</p>
<p>弃用的功能</p>
<p>以下几个功能被弃用，若在配置文件中启用，则 PHP 会在运行时发出警告。</p>
<p>Register Globals</p>
<p>这是 php.ini 中的一个选项(register_globals), 开启后会将所有表单变量($_GET和$_POST)注册为全局变量.<br>看下面的例子：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(isAuth())</span><br><span class="line">    <span class="variable">$authorized</span> = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$authorized</span>)</span><br><span class="line">    <span class="keyword">include</span>(<span class="string">"page.php"</span>);</span><br></pre></td></tr></table></figure>
<p>这段代码在通过验证时，将 $authorized 设置为 true. 然后根据 $authorized 的值来决定是否显示页面.</p>
<p>但由于并没有事先把 $authorized 初始化为 false, 当 register_globals 打开时，可能访问 /auth.php?authorized=1 来定义该变量值，绕过身份验证。</p>
<p>该特征属于历史遗留问题，在 PHP4.2 中被默认关闭，在 PHP5.4 中被移除。</p>
<p>Magic Quotes</p>
<p>对应 php.ini 中的选项 magic_quotes_gpc, 这个特征同样属于历史遗留问题，已经在 PHP5.4 中移除。</p>
<p>该特征会将所有用户输入进行转义，这看上去不错，在第一章我们提到过要对用户输入进行转义。<br>但是 PHP 并不知道哪些输入会进入 SQL , 哪些输入会进入 Shell, 哪些输入会被显示为 HTML, 所以很多时候这种转义会引起混乱。</p>
<p>Safe Mode</p>
<p>很多虚拟主机提供商使用 Safe Mode 来隔离多个用户，但 Safe Mode 存在诸多问题，例如某些扩展并不按照 Safe Mode 来进行权限控制。<br>PHP官方推荐使用操作系统的机制来进行权限隔离，让Web服务器以不同的用户权限来运行PHP解释器，请参见第一章中的最小权限原则.</p>
<p>匿名函数</p>
<p>也叫闭包(Closures), 经常被用来临时性地创建一个无名函数，用于回调函数等用途。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$func</span> = <span class="function"><span class="keyword">function</span><span class="params">(<span class="variable">$arg</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">print</span> <span class="variable">$arg</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="variable">$func</span>(<span class="string">"Hello World"</span>);</span><br></pre></td></tr></table></figure>
<p>以上代码定义了一个匿名函数，并赋值给了 $func.<br>可以看到定义匿名函数依旧使用 function 关键字，只不过省略了函数名，直接是参数列表。</p>
<p>然后我们又调用了 $func 所储存的匿名函数。</p>
<p>匿名函数还可以用 use 关键字来捕捉外部变量：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayPlus</span><span class="params">(<span class="variable">$array</span>, <span class="variable">$num</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    array_walk(<span class="variable">$array</span>, <span class="function"><span class="keyword">function</span><span class="params">(&amp;<span class="variable">$v</span>)</span> <span class="title">use</span><span class="params">(<span class="variable">$num</span>)</span></span>&#123;</span><br><span class="line">        <span class="variable">$v</span> += <span class="variable">$num</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码定义了一个 arrayPlus() 函数(这不是匿名函数), 它会将一个数组($array)中的每一项，加上一个指定的数字($num).</p>
<p>在 arrayPlus() 的实现中，我们使用了 array_walk() 函数，它会为一个数组的每一项执行一个回调函数，即我们定义的匿名函数。<br>在匿名函数的参数列表后，我们用 use 关键字将匿名函数外的 $num 捕捉到了函数内，以便知道到底应该加上多少。</p>
<p>魔术方法：<strong>invoke(), </strong>callStatic()</p>
<p>PHP 的面向对象体系中，提供了若干“魔术方法”，用于实现类似其他语言中的“重载”，如在访问不存在的属性、方法时触发某个魔术方法。</p>
<p>随着匿名函数的加入，PHP 引入了一个新的魔术方法 __invoke().<br>该魔术方法会在将一个对象作为函数调用时被调用：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span><span class="params">(<span class="variable">$str</span>)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"A::__invoke(): &#123;$str&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> A;</span><br><span class="line"><span class="variable">$a</span>(<span class="string">"Hello World"</span>);</span><br></pre></td></tr></table></figure>
<p>输出毫无疑问是：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A::__invoke(): Hello World</span><br></pre></td></tr></table></figure>
<p>__callStatic() 则会在调用一个不存在的静态方法时被调用。</p>
<p>命名空间</p>
<p>PHP的命名空间有着前无古人后无来者的无比蛋疼的语法：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="comment">// 命名空间的分隔符是反斜杠，该声明语句必须在文件第一行。</span></span><br><span class="line"><span class="comment">// 命名空间中可以包含任意代码，但只有 **类, 函数, 常量** 受命名空间影响。</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">XXOO</span>\<span class="title">Test</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 该类的完整限定名是 \XXOO\Test\A , 其中第一个反斜杠表示全局命名空间。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 你还可以在已经文件中定义第二个命名空间，接下来的代码将都位于 \Other\Test2 .</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Other</span>\<span class="title">Test2</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 实例化来自其他命名空间的对象：</span></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> \XXOO\Test\A;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 你还可以用花括号定义第三个命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Other</span> &#123;</span><br><span class="line">// 实例化来自子命名空间的对象：</span><br><span class="line">$<span class="title">b</span> = <span class="title">new</span> <span class="title">Test2</span>\<span class="title">B</span>;</span><br><span class="line"><span class="comment">// 导入来自其他命名空间的名称，并重命名，</span></span><br><span class="line"><span class="comment">// 注意只能导入类，不能用于函数和常量。</span></span><br><span class="line"><span class="keyword">use</span> \<span class="title">XXOO</span>\<span class="title">Test</span>\<span class="title">A</span> <span class="title">as</span> <span class="title">ClassA</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多有关命名空间的语法介绍请参见官网 [注].</p>
<p>命名空间时常和 autoload 一同使用，用于自动加载类实现文件：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spl_autoload_register(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="params">(<span class="variable">$class</span>)</span> </span>&#123;</span><br><span class="line">        spl_autoload(str_replace(<span class="string">"\\"</span>, <span class="string">"/"</span>, <span class="variable">$class</span>));</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>当你实例化一个类 \XXOO\Test\A 的时候，这个类的完整限定名会被传递给 autoload 函数，autoload 函数将类名中的命名空间分隔符(反斜杠)替换为斜杠，并包含对应文件。<br>这样可以实现类定义文件分级储存，按需自动加载。</p>
<p>注：<a href="http://www.php.net/manual/zh/language.namespaces.php" target="_blank" rel="external">http://www.php.net/manual/zh/language.namespaces.php</a></p>
<p>后期静态绑定</p>
<p>PHP 的 OPP 机制，具有继承和类似虚函数的功能，例如如下的代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">callFuncXXOO</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">print</span> <span class="variable">$this</span>-&gt;funcXXOO();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">funcXXOO</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A::funcXXOO()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">funcXXOO</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"B::funcXXOO"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> B;</span><br><span class="line"><span class="variable">$b</span>-&gt;callFuncXXOO();</span><br></pre></td></tr></table></figure>
<p>输出是：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B::funcXXOO</span><br></pre></td></tr></table></figure>
<p>可以看到，当在 A 中使用 $this-&gt;funcXXOO() 时，体现了“虚函数”的机制，实际调用的是 B::funcXXOO().<br>然而如果将所有函数都改为静态函数：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">callFuncXXOO</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">print</span> <span class="keyword">self</span>::funcXXOO();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">funcXXOO</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A::funcXXOO()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">funcXXOO</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"B::funcXXOO"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> B;</span><br><span class="line"><span class="variable">$b</span>-&gt;callFuncXXOO();</span><br></pre></td></tr></table></figure>
<p>情况就没这么乐观了，输出是：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A::funcXXOO()</span><br></pre></td></tr></table></figure>
<p>这是因为 self 的语义本来就是“当前类”，所以 PHP5.3 给 static 关键字赋予了一个新功能：后期静态绑定：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">callFuncXXOO</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">print</span> <span class="keyword">static</span>::funcXXOO();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>这样就会像预期一样输出了：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B::funcXXOO</span><br></pre></td></tr></table></figure>
<p>Heredoc 和 Nowdoc</p>
<p>PHP5.3 对 Heredoc 以及 Nowdoc 进行了一些改进，它们都用于在 PHP 代码中嵌入大段字符串。</p>
<p>Heredoc 的行为类似于一个双引号字符串：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$name</span> = <span class="string">"MyName"</span>;</span><br><span class="line"><span class="keyword">echo</span> &lt;&lt;&lt; TEXT</span><br><span class="line">My name is <span class="string">"&#123;$name&#125;"</span>.</span><br><span class="line">TEXT;</span><br><span class="line">```php</span><br><span class="line"></span><br><span class="line">Heredoc 以三个左尖括号开始，后面跟一个标识符(TEXT), 直到一个同样的顶格的标识符(不能缩进)结束。</span><br><span class="line">就像双引号字符串一样，其中可以嵌入变量。</span><br><span class="line"></span><br><span class="line">Heredoc 还可以用于函数参数，以及类成员初始化：</span><br><span class="line"></span><br><span class="line">```php</span><br><span class="line">var_dump(<span class="string">&lt;&lt;&lt;EOD</span><br><span class="line">Hello World</span><br><span class="line">EOD</span></span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> xx = &lt;&lt;&lt; EOD</span><br><span class="line">        Hello World</span><br><span class="line">        EOD;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$oo</span> = &lt;&lt;&lt; EOD</span><br><span class="line">        Hello World</span><br><span class="line">        EOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Nowdoc 的行为像一个单引号字符串，不能在其中嵌入变量，和 Heredoc 唯一的区别就是，三个左尖括号后的标识符要以单引号括起来：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$name</span> = <span class="string">"MyName"</span>;</span><br><span class="line"><span class="keyword">echo</span> &lt;&lt;&lt; <span class="string">'TEXT'</span></span><br><span class="line">My name is <span class="string">"&#123;$name&#125;"</span>.</span><br><span class="line">TEXT;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">My name is <span class="string">"&#123;$name&#125;"</span>.</span><br></pre></td></tr></table></figure>
<p>用 const 定义常量</p>
<p>PHP5.3 起同时支持在全局命名空间和类中使用 const 定义常量。</p>
<p>旧式风格：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">"XOOO"</span>, <span class="string">"Value"</span>);</span><br><span class="line">新式风格：</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> XXOO = <span class="string">"Value"</span>;</span><br></pre></td></tr></table></figure>
<p>const 形式仅适用于常量，不适用于运行时才能求值的表达式：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> XXOO = <span class="number">1234</span>;</span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">const</span> XXOO = <span class="number">2</span> * <span class="number">617</span>;</span><br></pre></td></tr></table></figure>
<p>三元运算符简写形式</p>
<p>旧式风格：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span> ? <span class="variable">$a</span> : <span class="string">"No Value"</span>;</span><br></pre></td></tr></table></figure>
<p>可简写成：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span> ?: <span class="string">"No Value"</span>;</span><br></pre></td></tr></table></figure>
<p>即如果省略三元运算符的第二个部分，会默认用第一个部分代替。</p>
<p>Phar</p>
<p>Phar即PHP Archive, 起初只是Pear中的一个库而已，后来在PHP5.3被重新编写成C扩展并内置到 PHP 中。<br>Phar用来将多个 .php 脚本打包(也可以打包其他文件)成一个 .phar 的压缩文件(通常是ZIP格式)。<br>目的在于模仿 Java 的 .jar, 不对，目的是为了让发布PHP应用程序更加方便。同时还提供了数字签名验证等功能。</p>
<p>.phar 文件可以像 .php 文件一样，被PHP引擎解释执行，同时你还可以写出这样的代码来包含(require) .phar 中的代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span>(<span class="string">"xxoo.phar"</span>);</span><br><span class="line"><span class="keyword">require</span>(<span class="string">"phar://xxoo.phar/xo/ox.php"</span>);</span><br></pre></td></tr></table></figure>
<p>更多信息请参见官网 [注].</p>
<p>注：<a href="http://www.php.net/manual/zh/phar.using.intro.php" target="_blank" rel="external">http://www.php.net/manual/zh/phar.using.intro.php</a></p>
<p>PHP5.4</p>
<p>(2012-2013)</p>
<p>Short Open Tag</p>
<p>Short Open Tag 自 PHP5.4 起总是可用。<br>在这里集中讲一下有关 PHP 起止标签的问题。即：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="comment">// Code...</span></span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>通常就是上面的形式，除此之外还有一种简写形式：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?</span> <span class="comment">/* Code... */</span> <span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>还可以把</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span> <span class="keyword">echo</span> <span class="variable">$xxoo</span>;<span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>简写成：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?</span>= <span class="variable">$xxoo</span>;<span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种简写形式被称为 Short Open Tag, 在 PHP5.3 起被默认开启，在 PHP5.4 起总是可用。<br>使用这种简写形式在 HTML 中嵌入 PHP 变量将会非常方便。</p>
<p>对于纯 PHP 文件(如类实现文件), PHP 官方建议顶格写起始标记，同时 省略 结束标记。<br>这样可以确保整个 PHP 文件都是 PHP 代码，没有任何输出，否则当你包含该文件后，设置 Header 和 Cookie 时会遇到一些麻烦 [注].</p>
<p>注：Header 和 Cookie 必须在输出任何内容之前被发送。</p>
<p>数组简写形式</p>
<p>这是非常方便的一项特征！</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原来的数组写法</span></span><br><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="string">"key"</span> =&gt; <span class="string">"value"</span>, <span class="string">"key2"</span> =&gt; <span class="string">"value2"</span>);</span><br><span class="line"><span class="comment">// 简写形式</span></span><br><span class="line"><span class="variable">$arr</span> = [<span class="string">"key"</span> =&gt; <span class="string">"value"</span>, <span class="string">"key2"</span> =&gt; <span class="string">"value2"</span>];</span><br></pre></td></tr></table></figure>
<p>Traits</p>
<p>所谓Traits就是“构件”，是用来替代继承的一种机制。PHP中无法进行多重继承，但一个类可以包含多个Traits.</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Traits不能被单独实例化，只能被类所包含</span></span><br><span class="line"><span class="keyword">trait</span> SayWorld</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'World!'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHelloWorld</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 将SayWorld中的成员包含进来</span></span><br><span class="line">    <span class="keyword">use</span> <span class="title">SayWorld</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="variable">$xxoo</span> = <span class="keyword">new</span> MyHelloWorld();</span><br><span class="line"><span class="comment">// sayHello() 函数是来自 SayWorld 构件的</span></span><br><span class="line"><span class="variable">$xxoo</span>-&gt;sayHello();</span><br></pre></td></tr></table></figure>
<p>Traits还有很多神奇的功能，比如包含多个Traits, 解决冲突，修改访问权限，为函数设置别名等等。<br>Traits中也同样可以包含Traits. 篇幅有限不能逐个举例，详情参见官网 [注].</p>
<p>注：<a href="http://www.php.net/manual/zh/language.oop5.traits.php" target="_blank" rel="external">http://www.php.net/manual/zh/language.oop5.traits.php</a></p>
<p>内置 Web 服务器</p>
<p>PHP从5.4开始内置一个轻量级的Web服务器，不支持并发，定位是用于开发和调试环境。</p>
<p>在开发环境使用它的确非常方便。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -S localhost:<span class="number">8000</span></span><br></pre></td></tr></table></figure>
<p>这样就在当前目录建立起了一个Web服务器，你可以通过 <a href="http://localhost:8000/" target="_blank" rel="external">http://localhost:8000/</a> 来访问。<br>其中localhost是监听的ip，8000是监听的端口，可以自行修改。</p>
<p>很多应用中，都会进行URL重写，所以PHP提供了一个设置路由脚本的功能:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -S localhost:<span class="number">8000</span> index.php</span><br></pre></td></tr></table></figure>
<p>这样一来，所有的请求都会由index.php来处理。</p>
<p>你还可以使用 XDebug 来进行断点调试。</p>
<p>细节修改</p>
<p>PHP5.4 新增了动态访问静态方法的方式：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$func</span> = <span class="string">"funcXXOO"</span>;</span><br><span class="line">A::&#123;<span class="variable">$func</span>&#125;();</span><br></pre></td></tr></table></figure>
<p>新增在实例化时访问类成员的特征:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> MyClass)-&gt;xxoo();</span><br></pre></td></tr></table></figure>
<p>新增支持对函数返回数组的成员访问解析(这种写法在之前版本是会报错的)：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> func()[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>PHP5.5</p>
<p>(2013起)</p>
<p>yield</p>
<p>yield关键字用于当函数需要返回一个迭代器的时候, 逐个返回值。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">number10</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">1</span>; <span class="variable">$i</span> &lt;= <span class="number">10</span>; <span class="variable">$i</span> += <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="variable">$i</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数的返回值是一个数组：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<p>list() 用于 foreach</p>
<p>可以用 list() 在 foreach 中解析嵌套的数组：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$array</span> = [</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$array</span> <span class="keyword">as</span> <span class="keyword">list</span>(<span class="variable">$a</span>, <span class="variable">$b</span>, <span class="variable">$c</span>))</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&#123;$a&#125; &#123;$b&#125; &#123;$c&#125;\n"</span>;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>细节修改</p>
<p>不推荐使用 mysql 函数，推荐使用 PDO 或 MySQLi, 参见前文。<br>不再支持Windows XP.</p>
<p>可用 MyClass::class 取到一个类的完整限定名(包括命名空间)。</p>
<p>empty() 支持表达式作为参数。</p>
<p>try-catch 结构新增 finally 块。</p>
<p>PHP5.6</p>
<p>更好的常量</p>
<p>定义常量时允许使用之前定义的常量进行计算：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> A = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> B = A + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> STR = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">const</span> STR2 = <span class="keyword">self</span>::STR + <span class="string">", world"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>允许常量作为函数参数默认值：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span><span class="params">(<span class="variable">$arg</span> = C::STR2)</span></span></span><br></pre></td></tr></table></figure>
<p>更好的可变函数参数</p>
<p>用于代替 func_get_args()</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(...<span class="variable">$args</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="variable">$result</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="variable">$args</span> <span class="keyword">as</span> <span class="variable">$arg</span>)</span><br><span class="line">    <span class="variable">$result</span> += <span class="variable">$arg</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时可以在调用函数时，把数组展开为函数参数：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$arr</span> = [<span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">add(<span class="number">1</span>, ...<span class="variable">$arr</span>);</span><br><span class="line"><span class="comment">// 结果为 6</span></span><br></pre></td></tr></table></figure>
<p>命名空间</p>
<p>命名空间支持常量和函数：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Name</span>\<span class="title">Space</span> &#123;</span><br><span class="line">    <span class="title">const</span> <span class="title">FOO</span> = 42;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">echo</span> <span class="keyword">__FUNCTION__</span>.<span class="string">"\n"</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="title">use</span> <span class="title">const</span> <span class="title">Name</span>\<span class="title">Space</span>\<span class="title">FOO</span>;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">function</span> <span class="title">Name</span>\<span class="title">Space</span>\<span class="title">f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> FOO.<span class="string">"\n"</span>;</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/转载/">转载</a><a class="article-category-link" href="/categories/转载/PHP/">PHP</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-2013-12-php-fsock-rsync" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2013/12/26/2013-12-php-fsock-rsync/" class="article-date">
  	<time datetime="2013-12-26T11:27:00.000Z" itemprop="datePublished">2013-12-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/12/26/2013-12-php-fsock-rsync/">PHP中使用fsock实现伪异步</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Web开发中，我们经常会遇到这样一个场景：用户发起一个请求，处理这个请求的业务很简单，可能几毫秒或者几十毫秒就能完成；但是这个请求会影响另外一个业务系统，所以我们在处理完用户的请求后，不得不发起一个新的后台请求到相关的业务系统，而相关的业务系统响应我们的后台请求可能非常慢，这样就会延长我们的整个响应时间。</p>
<p>  实例：我们的用户头像会保存到CDN，当用户更换头像的时候，上传写入可以很快的完成，但是调用CDN的purge接口可能要很久（好几秒），这样就会导致整个上传过程耗时很长。</p>
<p>当然，要解决这个问题有很多办法；比如把purge接口的请求丢给消息队列，后台计划任务不停地消费消息队列发起purge请求；如果这么做确实可以解决问题，但是把整体架构复杂化了。</p>
<p>不用消息队列，很多人就会想到用异步；但是项目使用的是PHP，它是顺序执行，不支持异步的，怎么办？</p>
<p>拜读Laruence早期的文章：</p>
<p>《PHP实现异步调用方法研究》<br>《使用fscok实现异步调用PHP》<br>根据文章中的介绍，果断采用fsockopen的方法：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncGet</span><span class="params">(<span class="variable">$url</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="variable">$parts</span> = parse_url(<span class="variable">$url</span>);</span><br><span class="line">    <span class="variable">$fp</span> = fsockopen(</span><br><span class="line">        <span class="variable">$parts</span>[<span class="string">'host'</span>],</span><br><span class="line">        <span class="keyword">isset</span>(<span class="variable">$parts</span>[<span class="string">'port'</span>]) ? <span class="variable">$parts</span>[<span class="string">'port'</span>] : <span class="number">80</span>,</span><br><span class="line">        <span class="variable">$errno</span>, <span class="variable">$errstr</span>, <span class="number">3</span></span><br><span class="line">    );</span><br><span class="line">    <span class="variable">$out</span> = <span class="string">"GET "</span> . <span class="variable">$parts</span>[<span class="string">'path'</span>] . <span class="string">" HTTP/1.1\r\n"</span>;</span><br><span class="line">    <span class="variable">$out</span> .= <span class="string">"Host: "</span> . <span class="variable">$parts</span>[<span class="string">'host'</span>] . <span class="string">"\r\n"</span>;</span><br><span class="line">    <span class="variable">$out</span> .= <span class="string">"Connection: Close\r\n\r\n"</span>;</span><br><span class="line">    fwrite(<span class="variable">$fp</span>, <span class="variable">$out</span>);</span><br><span class="line">    fclose(<span class="variable">$fp</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$start</span> = microtime(<span class="keyword">true</span>);</span><br><span class="line">asyncGet(</span><br><span class="line">    <span class="string">'http://cdn.ljf.me/purge.php'</span></span><br><span class="line">);</span><br><span class="line"><span class="variable">$end</span> = microtime(<span class="keyword">true</span>);</span><br><span class="line"><span class="variable">$cost</span> = <span class="variable">$end</span> - <span class="variable">$start</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"purge cdn cost: $cost s\n"</span>;</span><br></pre></td></tr></table></figure>
<p>问题来了，无论如何发送请求，服务器都没有正常地清洗缓存（直接输入url访问是可以正常清洗的，排除purge接口本身的问题）。</p>
<p>用WireShark抓到数据包来看，请求确实是有发出，也是正常的。</p>
<p>为什么请求有发出，但是服务器并没有进行清洗CDN工作，问题可能出现在哪里？</p>
<p>本地搭出一个测试环境。使用相同的脚本发完请求后，查看php-fpm的access日志没有找到刚才的请求，但是nginx的access是有这个请求的，状态码是499。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 - - [18/Dec/2013:11:57:57 +0800] "GET /purge.php HTTP/1.1" 499 0 "-" "-" "-"</span><br></pre></td></tr></table></figure>
<p>在HTTP协议中没有直接定义499的状态码，这个状态码是nginx指定的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* from ngx_http_request.h */</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * HTTP does not define the code for the case when a client closed</span><br><span class="line"> * the connection while we are processing its request so we introduce</span><br><span class="line"> * own code to log such situation when a client has closed the connection</span><br><span class="line"> * before we even try to send the HTTP header to it</span><br><span class="line"> */</span><br><span class="line">#define NGX_HTTP_CLIENT_CLOSED_REQUEST     499</span><br></pre></td></tr></table></figure>
<p>nginx对499的定义是”client has closed connection”，并且在这些情况下会返回这个状态码：</p>
<p>upstream 在收到读写事件处理之前时发现连接不可用。<br>server处理请求未结束，而client提前关闭了连接。<br>upstream出错，执行next_upstream时发现连接不可用。<br>现在的问题是：我们要等nginx的upstream处理完并且把请求交给fastcgi之后，才能主动关闭连接，否则就不能正常的清洗CDN的缓存了。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncGet</span><span class="params">(<span class="variable">$url</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="variable">$parts</span> = parse_url(<span class="variable">$url</span>);</span><br><span class="line">    <span class="variable">$fp</span> = fsockopen(</span><br><span class="line">        <span class="variable">$parts</span>[<span class="string">'host'</span>],</span><br><span class="line">        <span class="keyword">isset</span>(<span class="variable">$parts</span>[<span class="string">'port'</span>]) ? <span class="variable">$parts</span>[<span class="string">'port'</span>] : <span class="number">80</span>,</span><br><span class="line">        <span class="variable">$errno</span>, <span class="variable">$errstr</span>, <span class="number">3</span></span><br><span class="line">    );</span><br><span class="line">    <span class="variable">$out</span> = <span class="string">"GET "</span> . <span class="variable">$parts</span>[<span class="string">'path'</span>] . <span class="string">" HTTP/1.1\r\n"</span>;</span><br><span class="line">    <span class="variable">$out</span> .= <span class="string">"Host: "</span> . <span class="variable">$parts</span>[<span class="string">'host'</span>] . <span class="string">"\r\n"</span>;</span><br><span class="line">    <span class="variable">$out</span> .= <span class="string">"Connection: Close\r\n\r\n"</span>;</span><br><span class="line">    fwrite(<span class="variable">$fp</span>, <span class="variable">$out</span>);</span><br><span class="line">    usleep(<span class="number">10000</span>);</span><br><span class="line">    fclose(<span class="variable">$fp</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个不安全的做法是在fclose之前，让当前的进程先睡眠一段时间；我这里设置为10毫秒，这10毫秒的延迟对我完成整个请求的影响不大，同时我也认为nginx一定能在10毫米内把请求转到fastcgi去执行。这个时间间隔很难把握，不能保证php一定有执行到。</p>
<p>这种方式并不是真正的异步，只是很取巧的强制关闭连接而不等待服务器端响应。所以在Laruence的那2篇文章中，有2个问题：</p>
<p>PHP使用fsock不能叫做异步，只是伪异步。<br>fwrite之后马上执行fclose，nginx会直接返回499。<br>Laruence这2篇博文都是08年写的，不知道当时是不是用apache做的测试。因为没有使用apache的场景，所以也就不打算用apache再验证一次。</p>
<p>转载自：<a href="http://ljf.me/archives/use-sock-to-implement-the-async-in-php" target="_blank" rel="external">http://ljf.me/archives/use-sock-to-implement-the-async-in-php</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/转载/">转载</a><a class="article-category-link" href="/categories/转载/PHP/">PHP</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-2013-11-nginx-fpm-file-not-find" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2013/11/22/2013-11-nginx-fpm-file-not-find/" class="article-date">
  	<time datetime="2013-11-22T02:29:00.000Z" itemprop="datePublished">2013-11-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/11/22/2013-11-nginx-fpm-file-not-find/">ubuntu下配置nginx+php-fpm的file not find问题</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>第一种情况下sudo vim /etc/nginx/sites-enable/default下配置</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">    <span class="title">try_files</span> <span class="variable">$uri</span> =<span class="number">404</span>;</span><br><span class="line">    <span class="title">fastcgi_split_path_info</span><span class="regexp"> ^(.+\.php)(/.+)$</span>;</span><br><span class="line">    <span class="title">fastcgi_pass</span> <span class="url">unix:/var/run/php5-fpm.sock</span>;</span><br><span class="line">    <span class="title">fastcgi_index</span> index.php;</span><br><span class="line">    <span class="title">fastcgi_read_timeout</span> <span class="number">300</span>;</span><br><span class="line">    <span class="title">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">    <span class="title">include</span> fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种情况就是 /etc/php5/fpm/pool.d/www.conf</p>
<p>文件配置下user = XXX必须与你/etc/nginx/nginx.conf的配置下user =XXX 一置，而且XXX必须是有访问权限。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/原创/">原创</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-2013-11-phpmyadmin-mcrypt-extension-is-missing" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2013/11/22/2013-11-phpmyadmin-mcrypt-extension-is-missing/" class="article-date">
  	<time datetime="2013-11-22T02:21:00.000Z" itemprop="datePublished">2013-11-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/11/22/2013-11-phpmyadmin-mcrypt-extension-is-missing/">phpmyadmin页面提示mcrypt extension is missing错误解决</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这是一个mcrypt文件位置错误的bug</p>
<p>详细的bug信息请参考以下网址：</p>
<p><a href="https://bugs.launchpad.net/ubuntu/+source/phpmyadmin/+bug/1236035" target="_blank" rel="external">https://bugs.launchpad.net/ubuntu/+source/phpmyadmin/+bug/1236035</a></p>
<p>#mv -i /etc/php5/conf.d/mcrypt.ini /etc/php5/mods-available/</p>
<p>#sudo php5enmod mcrypt</p>
<p>#/etc/init.d/apache2 restart</p>
<h2 id="ubuntu下phpmyadmin显示缺少_mcrypt_扩展。请检查_PHP_配置。">ubuntu下phpmyadmin显示缺少 mcrypt 扩展。请检查 PHP 配置。</h2><p>更新:2014-05-24<br>一般来说出现这个问题是由于没有安装mcrypt和配置导致的。<br>ubuntu下安装:sudo apt-get install php5-mcrypt libmcrypt-dev<br>安装之后如果仍然显示错误，则需要配置php扩展，一般来说配置文件都是在/etc/php5/下<br>你会在/etc/php5/mods-available/下看到配置文件mcrypt.ini，也可能在/etc/php5/conf.d/下，这时你只要将它链接到/etc/php5/fpm/conf.d/下就可以（cli和cgi类似就行）<br>命令：ln -s /etc/php5/mods-available/mcrypt.ini /etc/php5/fpm/conf.d/20-mcrypt.ini</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/原创/">原创</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-2013-10-multi-process-write" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2013/10/27/2013-10-multi-process-write/" class="article-date">
  	<time datetime="2013-10-27T13:17:00.000Z" itemprop="datePublished">2013-10-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/10/27/2013-10-multi-process-write/">多进程写文件</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多进程写文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write_file</span><span class="params">(<span class="variable">$filename</span>, <span class="variable">$content</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="variable">$lock</span> = <span class="variable">$filename</span> . <span class="string">'.lck'</span>;<span class="comment">//与文件名关联的加锁文件</span></span><br><span class="line">    <span class="variable">$write_length</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>( file_exists(<span class="variable">$lock</span>) ) &#123;<span class="comment">//判断是否已存在该锁，存在则证明已有进程在写文件，休眠100毫秒</span></span><br><span class="line">            usleep(<span class="number">100</span>);<span class="comment">//休眠100毫秒</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            touch(<span class="variable">$lock</span>);<span class="comment">//加锁</span></span><br><span class="line">            <span class="variable">$write_length</span> = file_put_contents(<span class="variable">$filename</span>, <span class="variable">$content</span>, FILE_APPEND);<span class="comment">//写文件</span></span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//退出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( file_exists(<span class="variable">$lock</span>) ) &#123;</span><br><span class="line">        unlink(<span class="variable">$lock</span>);<span class="comment">//解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$write_length</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/原创/">原创</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-2013-10-php-foreach-object" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2013/10/27/2013-10-php-foreach-object/" class="article-date">
  	<time datetime="2013-10-27T13:12:00.000Z" itemprop="datePublished">2013-10-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/10/27/2013-10-php-foreach-object/">使对象可以像数组一样进行foreach循环，要求属性必须是私有。(Iterator模式的PHP5实现，写一类实现Iterator接口)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>使对象可以像数组一样进行foreach循环，要求属性必须是私有。</p>
<p>刚接触到题的时候，我也没有考虑到Iterator模式，试了几个一般想法，失败以后。。。。就直接去翻看了foreach的源码实现，期望发现foreach处理对象的时候是否有什么特殊性，可以做为突破口。</p>
<p>跟踪了半天以后发现了核心逻辑中的一个奇怪的switch:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (zend_iterator_unwrap(<span class="built_in">array</span>, &amp;iter TSRMLS_CC)) &#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">case</span> ZEND_ITER_INVALID:</span><br><span class="line">               .....</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> ZEND_ITER_PLAIN_OBJECT: &#123;</span><br><span class="line">                ......</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> ZEND_ITER_PLAIN_ARRAY:</span><br><span class="line">            .....</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ZEND_ITER_OBJECT:</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个结构，我们可以看到，对象分为ZEND_ITER_OBJECT和ZEND_ITER_PLAIN_OBJECT, 这是什么意思呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ZEND_API <span class="keyword">enum</span> zend_object_iterator_kind <span class="title">zend_iterator_unwrap</span><span class="params">(</span><br><span class="line">    zval *array_ptr, zend_object_iterator **iter TSRMLS_DC)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (Z_TYPE_P(array_ptr)) &#123;</span><br><span class="line">        <span class="keyword">case</span> IS_OBJECT:</span><br><span class="line">            <span class="keyword">if</span> (Z_OBJ_HT_P(array_ptr) == &amp;iterator_object_handlers) &#123;</span><br><span class="line">                *iter = (zend_object_iterator *)zend_object_store_get_object(array_ptr TSRMLS_CC);</span><br><span class="line">                <span class="keyword">return</span> ZEND_ITER_OBJECT;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (HASH_OF(array_ptr)) &#123;</span><br><span class="line">                <span class="keyword">return</span> ZEND_ITER_PLAIN_OBJECT;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ZEND_ITER_INVALID;</span><br><span class="line">        <span class="keyword">case</span> IS_ARRAY:</span><br><span class="line">            <span class="keyword">if</span> (HASH_OF(array_ptr)) &#123;</span><br><span class="line">                <span class="keyword">return</span> ZEND_ITER_PLAIN_ARRAY;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ZEND_ITER_INVALID;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> ZEND_ITER_INVALID;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就要讲到PHP的内置接口Iterator了，PHP5开始支持了接口， 并且内置了Iterator接口， 所以如果你定义了一个类，并实现了Iterator接口，那么你的这个类对象就是ZEND_ITER_OBJECT,否则就是 ZEND_ITER_PLAIN_OBJECT.</p>
<p>对于ZEND_ITER_PLAIN_OBJECT的类，foreach会通过HASH_OF获取该对象的默认属性数组，然后对该数组进行foreach.<br>而对于ZEND_ITER_OBJECT的类对象，则会通过调用对象实现的Iterator接口相关函数来进行foreach， 所以， 对于这道笔试题， 可以作出如下的答案：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sample</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$_items </span>= <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  ;<span class="comment">//void</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">rewind</span><span class="params">()</span> </span>&#123; reset(<span class="variable">$this</span>-&gt;_items); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">current</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> current(<span class="variable">$this</span>-&gt;_items); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">key</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key(<span class="variable">$this</span>-&gt;_items); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> next(<span class="variable">$this</span>-&gt;_items); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">valid</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ( <span class="variable">$this</span>-&gt;current() !== <span class="keyword">false</span> ); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$sa </span>= <span class="keyword">new</span> sample();</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$sa as </span><span class="variable">$key </span>=&gt; <span class="variable">$val</span>)&#123;</span><br><span class="line">    <span class="keyword">print</span> <span class="variable">$key </span>. <span class="string">"=&gt;"</span> .<span class="variable">$val</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转载：<a href="http://www.laruence.com/2008/10/31/574.html" target="_blank" rel="external">http://www.laruence.com/2008/10/31/574.html</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/转载/">转载</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-2013-10-apache-rewrite-403" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2013/10/22/2013-10-apache-rewrite-403/" class="article-date">
  	<time datetime="2013-10-21T16:24:00.000Z" itemprop="datePublished">2013-10-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/10/22/2013-10-apache-rewrite-403/">apache rewriteEngine开启后出现403</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>apache伪静态URL配置RewriteEngine on出现403错误</p>
<p>解决方案：<br>1.在apache配置文件httpd.conf中，修改两项配置: Options FollowSymLinks、AllowOverride All。<br>2.把Options Indexes注释掉，也就是前面加个“#”，变成#Options Indexes</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/原创/">原创</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-2013-10-process-port-80-occupancy" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2013/10/21/2013-10-process-port-80-occupancy/" class="article-date">
  	<time datetime="2013-10-21T10:50:00.000Z" itemprop="datePublished">2013-10-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/10/21/2013-10-process-port-80-occupancy/">80端口被PID为4的系统进程所占用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>装apache的时候80端口被PID为4的系统进程所占用 由于工作中需要直接从MySQL后台读取数据，所以安装了PHPnow，装的过程中提示Apache安装失败，80端口被占用。 在cmd中输入netstat –ano命令，发现80端口被一个PID为4的服务所占用，打开任务管理器，发现PID为4的进程为系统进程，其描述信息为NT Kernel &amp; System，在服务里面又找不到PID为4的服务，所以没法停掉服务。 这种情况基本上就是谷歌和度娘的事了，搜出来的结果大部分不靠谱，要么说迅雷等下载软件会占用80端口，要么说IIS占用了该端口。事实上，我机器上这些服务都没启动。那么究竟是什么原因呢？还好，偶然间看到一个页面说MS SQL Server的报表服务会占用80端口（写日志的时候已经找不到链接了，恕未引用），于是打开windows服务，找到SQL Server Reporting Services (MYSQLSERVER)，把它停掉，再安装PHPnow，发现果然能顺利安装。 以后遇到类似问题，关掉SQL Server Reporting Services (MYSQLSERVER)也可以作为一种尝试了。</p>
<p>一些查看端口占用和关闭端口的命令，已443端口为例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano|findstr <span class="string">"443"</span> //搜索<span class="number">443</span>端口占用情况，并找到进程ID</span><br><span class="line">TCP <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">443</span> <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">0</span> LISTENING <span class="number">720</span> //找到PID为<span class="number">720</span></span><br><span class="line">UDP <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">59443</span> *:* <span class="number">7584</span></span><br><span class="line">-----------------------------------------------</span><br><span class="line">tasklist|findstr <span class="string">"720"</span> //查找PID为<span class="number">720</span>对应的进程名</span><br><span class="line">QQDownload.exe <span class="number">720</span> Console <span class="number">1</span> <span class="number">56</span>,<span class="number">156</span> K //找到是QQ旋风占用，结束掉进程。OK</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/原创/">原创</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-2013-10-text-similarity-algorithm-php" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2013/10/03/2013-10-text-similarity-algorithm-php/" class="article-date">
  	<time datetime="2013-10-02T17:09:00.000Z" itemprop="datePublished">2013-10-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/10/03/2013-10-text-similarity-algorithm-php/">用余弦定理实现文本相似度算法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>续上一篇文章的算法，这次自己改成PHP版本，当然如果有优化的地方请指出，以便大家学习。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line">header(<span class="string">'Content-Type: text/html; charset=UTF-8'</span>);</span><br><span class="line"><span class="variable">$text1</span> = <span class="string">&lt;&lt;&lt;EOF</span><br><span class="line">Fragment A (By Rousseau)：</span><br><span class="line">À l’instant, au lieu de la personne particulière de chaque contractant, cet acte d’association produit un Corps moral et collectif, composé d’autant de membres que l’assemblée a de voix, lequel reçoit de ce même acte son unité, son moi commun, sa vie et sa volonté. Cette personne publique, qui se forme ainsi par l’union de toutes les autres, prenait autrefois le nom de Cité , et prend maintenant celui de République ou de Corps politique: lequel est appelé par ses membres État quand il est passif, Souverain quand il est actif, Puissance en le comparant à ses semblables. À l’égard des associés, ils prennent collectivement le nom de peuple, et s’appellent en particulier citoyens, comme participant à l’autorité souveraine, et sujets, comme soumis aux lois de l’État. (Rousseau, Du contrat social, I.6)</span><br><span class="line">EOF;</span></span><br><span class="line"><span class="variable">$text2</span> = <span class="string">&lt;&lt;&lt;EOF</span><br><span class="line">Fragment B (By Hobbes)：</span><br><span class="line">Art goes yet further, imitating that Rationall and most excellent worke of Nature, Man. For by Art is created that great LEVIATHAN called a COMMON-WEALTH, or STATE, (in latine CIVITAS) which is but an Artificiall Man; though of greater stature and strength than the Naturall, for whoseprotection and defence it was intended; and in which, the Soveraignty is an Artificiall Soul, as giving life and motion to the whole body; The Magistrates, and other Officers of Judicature and Execution, artificiall Joynts; Reward and Punishment (by which fastned to the seat of the Soveraignty, every joynt and member is moved to performe his duty) are the Nerves, that do the same in the Body Naturall; The Wealth and Riches of all the particular members, are the Strength; Salus Populi (the Peoples Safety) its Businesse; Counsellors, by whom all things needfull for it to know, are suggested unto it, are the Memory; Equity and Lawes, an artificiall Reason and Will; Concord, Health; Sedition, Sicknesse; and Civill War, Death. Lastly, the Pacts and Covenants, by which the parts of this Body Politique were at first made, set together, and united, resemble that Fiat, or the Let Us Make Man, pronounced by God in the Creation. (Hobbes, Leviathan, "Introduction"）</span><br><span class="line">EOF;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> similarAlgorithm(<span class="variable">$text1</span> , <span class="variable">$text2</span>);</span><br><span class="line"><span class="comment">/*</span><br><span class="line">* 文本相似度匹配</span><br><span class="line">* <span class="doctag">@author</span> juice</span><br><span class="line">* <span class="doctag">@param</span> text1 匹配文本1</span><br><span class="line">* <span class="doctag">@param</span> text2 匹配文本2</span><br><span class="line">* <span class="doctag">@return</span> double 返回相似度(余弦值)</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">similarAlgorithm</span><span class="params">(<span class="variable">$text1</span> = <span class="string">''</span> , <span class="variable">$text2</span> = <span class="string">''</span>)</span></span>&#123;</span><br><span class="line">    <span class="variable">$charset</span> = <span class="string">'UTF-8'</span> ;</span><br><span class="line">    <span class="variable">$text1Array</span> = mbStringToArray(<span class="variable">$text1</span> , <span class="variable">$charset</span> ,<span class="keyword">TRUE</span>);</span><br><span class="line">    <span class="variable">$text2Array</span> = mbStringToArray(<span class="variable">$text2</span> , <span class="variable">$charset</span> ,<span class="keyword">TRUE</span>);</span><br><span class="line">    <span class="variable">$textSumArray</span> = <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="variable">$text1Array</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$val</span>)&#123;<span class="comment">//统计该字在第一文本中出现的次数</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$textSumArray</span>[<span class="variable">$val</span>]))&#123;</span><br><span class="line">            <span class="variable">$textSumArray</span>[<span class="variable">$val</span>][<span class="number">0</span>]++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$textSumArray</span>[<span class="variable">$val</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="variable">$textSumArray</span>[<span class="variable">$val</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="variable">$text2Array</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$val</span>)&#123;<span class="comment">//统计该字在第二文本中出现的次数</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$textSumArray</span>[<span class="variable">$val</span>]))&#123;</span><br><span class="line">            <span class="variable">$textSumArray</span>[<span class="variable">$val</span>][<span class="number">1</span>]++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$textSumArray</span>[<span class="variable">$val</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="variable">$textSumArray</span>[<span class="variable">$val</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$sqdoc1</span> = <span class="number">0</span>;<span class="comment">//平方和</span></span><br><span class="line">    <span class="variable">$sqdoc2</span> = <span class="number">0</span>;<span class="comment">//平方和</span></span><br><span class="line">    <span class="variable">$denominator</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="variable">$textSumArray</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$val</span>)&#123;</span><br><span class="line">        <span class="variable">$denominator</span> += <span class="variable">$val</span>[<span class="number">0</span>] * <span class="variable">$val</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="variable">$sqdoc1</span> += <span class="variable">$val</span>[<span class="number">0</span>] * <span class="variable">$val</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="variable">$sqdoc2</span> += <span class="variable">$val</span>[<span class="number">1</span>] * <span class="variable">$val</span>[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$denominator</span> / sqrt(<span class="variable">$sqdoc1</span>*<span class="variable">$sqdoc2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span><br><span class="line">* 分割字符串方法 （支持中文分割）</span><br><span class="line">* <span class="doctag">@author</span> juice</span><br><span class="line">* <span class="doctag">@param</span> str 需要分割的字符串</span><br><span class="line">* <span class="doctag">@param</span> charset 字符串的编码，默认UTF-8</span><br><span class="line">* <span class="doctag">@param</span> convertedToHex 是否返回该字符的16进制，TRUE返回每个字符16进制，FALSE则返回原本字符</span><br><span class="line">* <span class="doctag">@return</span> double 返回相似度(余弦值)</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mbStringToArray</span><span class="params">(<span class="variable">$str</span> = <span class="string">''</span>,<span class="variable">$charset</span> = <span class="string">'UTF-8'</span> , <span class="variable">$convertedToHex</span> = FALSE)</span> </span>&#123;</span><br><span class="line">    <span class="variable">$strlen</span> = mb_strlen(<span class="variable">$str</span>);</span><br><span class="line">    <span class="keyword">if</span>( <span class="variable">$convertedToHex</span> === <span class="keyword">TRUE</span> )&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="variable">$strlen</span>)&#123;</span><br><span class="line">            <span class="variable">$array</span>[] = bin2hex(mb_substr(<span class="variable">$str</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="variable">$charset</span>));</span><br><span class="line">            <span class="variable">$str</span> = mb_substr(<span class="variable">$str</span>,<span class="number">1</span>,<span class="variable">$strlen</span>,<span class="variable">$charset</span>);</span><br><span class="line">            <span class="variable">$strlen</span> = mb_strlen(<span class="variable">$str</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="variable">$strlen</span>)&#123;</span><br><span class="line">            <span class="variable">$array</span>[] = mb_substr(<span class="variable">$str</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="variable">$charset</span>);</span><br><span class="line">            <span class="variable">$str</span> = mb_substr(<span class="variable">$str</span>,<span class="number">1</span>,<span class="variable">$strlen</span>,<span class="variable">$charset</span>);</span><br><span class="line">            <span class="variable">$strlen</span> = mb_strlen(<span class="variable">$str</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$array</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/原创/">原创</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/archives/">&laquo; Prev</a><a class="page-number" href="/archives/">1</a><span class="page-number current">2</span><a class="page-number" href="/archives/page/3/">3</a><a class="extend next" rel="next" href="/archives/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 juice
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: undefined,
		isHome: false,
		isPost: false,
		isArchive: true,
		isTag: false,
		isCategory: false,
		open_in_new: undefined
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>